# Agent_text2SQL

Агент превращает вопрос пользователя на естественном языке в SQL-запрос, безопасно проверяет его, выполняет к базе данных и формирует финальный ответ. Встроены ретраи на выбор таблиц и на валидацию SQL.

## Возможности

- Принимает текстовый вопрос пользователя
- Подбирает релевантные таблицы и колонки по схеме БД
- Генерирует SQL-запрос
- Проверяет SQL на стоп-слова (запрещённые конструкции)
- Выполняет SQL и обрабатывает ошибки
- Делает ретраи (до 3 попыток) на ключевых шагах
- Возвращает человекочитаемый ответ по результатам запроса

## Общий пайплайн

0) Получить вопрос пользователя  
1) Выбрать релевантные таблицы (до 3 попыток)  
2) Выбрать релевантные колонки  
3) Сгенерировать SQL (с учётом выбранных таблиц и колонок; счётчик попыток генерации)  
4) Проверить SQL на стоп-слова (если найдены — вернуться к генерации SQL)  
5) Выполнить SQL  
6) При ошибке выполнения/синтаксиса — валидировать и регенерировать SQL (до 3 попыток)  
7) Сформировать финальный ответ

## Параметры и контракты шагов

### Шаг 0 — Получение запроса
**Вход:**
- `question: str`

**Выход:**
- `question: str`

***

### Шаг 1 — Выбор таблиц (retrieval)
Агент пытается определить, какие таблицы нужны для ответа. Если не удаётся — повторяет до 3 раз. После 3 неудач выбрасывает ошибку домена.

**Вход:**
- `question: str`
- `relevant_tables: Dict[str, List[str]]`
- `error: Optional[str]` (инфо о причине прошлой неудачи, если была)
- `table_counter: int` (счётчик попыток; увеличивается на каждой попытке)

**Выход:**
- `relevant_tables: Dict[str, List[str]]` (выбранные таблицы)
- или ошибка: `Вопрос не по теме`

**Логика ретраев:**
- Максимум \(3\) попытки (`table_counter <= 3`)
- Если подходящих таблиц нет → повторить
- Если после 3 попыток нет результата → ошибка `Вопрос не по теме`

***

### Шаг 2 — Выбор колонок
На основе таблиц выбираются релевантные колонки.

**Вход:**
- `question: str`
- `relevant_tables_with_rel_columns: Dict[str, List[str]]` (заполняется на этом шаге)

**Выход:**
- `relevant_tables_with_rel_columns: Dict[str, List[str]]`

***

### Шаг 3 — Генерация SQL
Генерирует SQL-запрос, опираясь на выбранные таблицы и колонки. Ведётся счётчик попыток генерации.

**Вход:**
- `question: str`
- `relevant_tables_with_rel_columns: Dict[str, List[str]]`
- `sql_generate_count: int` (увеличивается на каждой генерации)

**Выход:**
- `sql_request: str`

***

### Шаг 4 — Проверка на стоп-слова
Проверяет SQL на запрещённые конструкции. Если они обнаружены, нужно регенерировать запрос (вернуться к шагу 3).

**Вход:**
- `sql_request: str`

**Выход:**
- `stop_words: bool` (нашлись ли стоп-слова)
- `used_stop_words: List[str]` (какие именно)

**Переходы:**
- Если `stop_words == True` → вернуться к шагу 3
- Иначе → перейти к шагу 5

***

### Шаг 5 — Выполнение SQL
Выполняет запрос к БД.

**Вход:**
- `sql_request: str`

**Выход (успех):**
- `sql_request_is_valid: bool = True`
- `result: Optional[str]`

**Выход (ошибка):**
- `sql_request_is_valid: bool = False`
- `sql_error_info: Optional[str]` (текст/код ошибки)
- переход к шагу 6

***

### Шаг 6 — Валидация и регенерация SQL (до 3 попыток)
Если SQL не выполнился, агент использует `sql_error_info`, чтобы уточнить генерацию на шаге 3. Максимум 3 попытки; затем ошибка.

**Вход:**
- `question: str`
- `relevant_tables_with_rel_columns: Dict[str, List[str]]`
- `sql_request: str`
- `sql_error_info: Optional[str]`
- `sql_request_is_valid: bool`

**Логика ретраев:**
- До \(3\) циклов “ошибка выполнения → шаг 6 → шаг 3 -> шаг 4 -> шаг 5"
- Если после 3 попыток всё ещё невалидно → ошибка: `Не получилось сгенерировать SQL запрос`

***

### Шаг 7 — Генерация ответа
Преобразует результат БД в ответ.

**Вход:**
- `question: str`
- `result: Optional[str]`

**Выход:**
- `answer: Optional[str]`

## Ошибки

- `Вопрос не по теме` — не удалось подобрать таблицы за 3 попытки
- `Не получилось сгенерировать SQL запрос` — не удалось получить валидный SQL за 3 попытки регенерации после ошибок выполнения















